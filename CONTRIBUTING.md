Project structure
=================

- `root`: Contains tests and nothing else
  - `codegen`: Codegen core. Defines algebras and default interpreters.
  - `sample`: Contains integration tests for generated code. May be generated via `example` in the sbt console.

Coding guidelines
=================

- Readability
- Maintainability
- Testability
- Defer effects
- Typesafe accessors for Java function calls
  - [`Extractable`](../modules/codegen/src/main/scala/com/twilio/guardrail/extract/Extractable.scala)
  - [`VendorExtensible`](../modules/codegen/src/main/scala/com/twilio/guardrail/extract/VendorExtension.scala)

Writing integration Tests
=========================

It is difficult to tell if the code generated by the tool is functional and type
sound by structure alone. As unit tests are not enough, integration tests
actually run guardrail as a CLI tool to generate complete clients and servers,
ensuring everything works as expected.

The project defined at `modules/sample` is divided into two parts:
 - `src/main`: Completely generated code, `.gitignore` explicitly prevents these files from being tracked.
 - `src/test`: Manually written integration tests against the generated code. These tests are run by the `testSuite` command.

By running guardrail, then attempting to compile the generated code, then
running integration tests against the generated code, we can ensure quality.

Adding a new swagger spec
-------------------------

Adding new specifications is accomplished by:

 - creating a file in `modules/sample/src/main/resources`
 - adding an entry in `exampleCases` defined in `build.sbt`. The available flags are largely undocumented, so [reading the parser](https://github.com/twilio/guardrail/blob/master/modules/codegen/src/main/scala/com/twilio/guardrail/core/CoreTermInterp.scala#L67-L91) is necessary.

```scala
val exampleCases: List[(java.io.File, String, Boolean, List[String])] = List(
  (sampleResource("additional-properties.yaml"), "additionalProperties", false, List.empty),
  (sampleResource("alias.yaml"), "alias", false, List.empty),
```

- First argument has to point to the newly added specification file. `sampleResource` looks up the specification in `modules/sample/src/main/resources`
- Second argument defines what package to put the specification into (For regression tests, `issues.issue1234`)
- Third argument is whether "tracing" is enabled
- Fourth argument is a list of additional CLI flags to specify

Adding tests
------------

Define your tests in `./modules/sample-*/src/test/scala` make sure to use
imports corresponding the previously defined `packageName`

Running the tests
-----------------

Use the `runtimeSuite` command inside of an SBT session to run code generation and execute the tests


Useful commands inside sbt console
==================================

- `testSuite`: Compile, test codegen, run sample codegen, compile sample, run tests inside sample
- `runtimeSuite`: Run guardrail, then run all tests against the generated code
- `cli`: Useful for scripting: `sbt 'cli --client ...'`
- `format`: Runs scalafmt against codebase
- `checkFormatting`: Verifies formatting, run as part of CI against PRs

Resources
=========

- Cats' Free Monad: http://typelevel.org/cats/datatypes/freemonad.html
- Scalameta Quasiquotes: https://github.com/scalameta/scalameta/blob/master/notes/quasiquotes.md
